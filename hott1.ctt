module hott1 where
import algebra
import basic
import definitions1

-- exercise 1.1
compose (A B C : U) (g : B -> C) (f : A -> B) : A -> C =
  \(x : A) -> g (f x)

composeAssoc (A B C D : U) (h : C -> D) (g : B -> C) (f : A -> B) :
  Path (A -> D) (compose A C D h (compose A B C g f))
                (compose A B D (compose B C D h g) f) =
  refl (A -> D) (\(x : A) -> h (g (f x)))

-- exercise 1.2
recTupleFromPr (A B C : U) (g : A -> B -> C) (x : Tuple A B) : C =
  g (pr1Tuple A B x) (pr2Tuple A B x)

recExistsFromPr
  (A C : U) (B : A -> U)
  (g : (x : A) -> B x -> C) (p : (x : A) * B x) : C =
  g (pr1Exists A B p) (pr2Exists A B p)

-- exercise 1.3

indTupleFromPr
  (A B : U) (C : Tuple A B -> U)
  (g : (x : A) -> (y : B) -> C (pair x y))
  (x : Tuple A B) : C x =
  transport (<i> C (uniqTuple A B x @ i))
            (g (pr1Tuple A B x) (pr2Tuple A B x))

uniqExists (A : U) (B : A -> U) (x : (a : A) * (B a)) :
         Path ((a : A) * B a)
	      (pr1Exists A B x, pr2Exists A B x) x =
  refl ((a : A) * B a) x

indExistsFromPr
  (A : U) (B : A -> U) (C : ((x : A) * B x) -> U)
  (g : (x : A) -> (y : B x) -> C (x, y))
  (x : (x : A) * (B x)) : C x =
  transport (<i> C (uniqExists A B x @ i))
            (g (pr1Exists A B x) (pr2Exists A B x))

-- exercise 1.4

iter (C : U) (c0 : C) (cs : C -> C) : Nat -> C = split
  zero -> c0
  succ n -> cs (iter C c0 cs n)

iterStep (C : U) (cs : Nat -> C -> C) (p : Sigma Nat C) : Sigma Nat C =
  (succ p.1, cs p.1 p.2)

recNatFromIter' (C : U) (c0 : C) (cs : Nat -> C -> C) (n : Nat) :
                Sigma Nat C =
  iter (Sigma Nat C) (zero, c0) (iterStep C cs) n

recNatFromIter (C : U) (c0 : C) (cs : Nat -> C -> C) (n : Nat) : C =
  (recNatFromIter' C c0 cs n).2

recNatIterEq (C : U) (c0 : C) (cs : Nat -> C -> C) : (n : Nat) ->
  Path (Sigma Nat C) (n, recNat C c0 cs n)
                     (recNatFromIter' C c0 cs n) = undefined

-- exercise 1.5

CoproductB (A B : U) : U = (x : Bool) * (recBool U A B x)

inlB (A B : U) (a : A) : CoproductB A B = (false, a)

inrB (A B : U) (b : B) : CoproductB A B = (true, b)

indCoproductB (A B C : U) (C : CoproductB A B -> U)
              (g0 : (a : A) -> C (inlB A B a))
              (g1 : (b : B) -> C (inrB A B b))
              (x : CoproductB A B) : C x = undefined

-- exercise 1.8

multRec : Nat -> Nat -> Nat =
  recNat (Nat -> Nat) (\(_ : Nat) -> zero)
         (\(n : Nat) (g : Nat -> Nat) (m : Nat) -> addRec m (g m))

pownRecFlipped : Nat -> Nat -> Nat =
  recNat (Nat -> Nat) (\(_ : Nat) -> (succ zero))
         (\(n : Nat) (g : Nat -> Nat) (m : Nat) -> multRec m (g m))

pownRec (n : Nat) (m : Nat) : Nat = pownRecFlipped m n

-- Yes, we have already defined add—addRec—through
-- recursor of natural numbers,
-- but proofs with it is so ugly and complicated,
-- that I think, that add defined through
-- pattern‐matching is 100 times better.
add (m : Nat) : Nat -> Nat = split
  zero -> m
  succ n -> succ (add m n)

-- The same thing
mult : Nat -> Nat -> Nat = split
  zero -> const Nat Nat zero
  succ n -> \(m : Nat) ->
    add m (mult n m)

addZero : (a : Nat) -> Path Nat (add zero a) a = split
  zero -> <_> zero
  succ a -> <i> succ (addZero a @ i)

addSucc (a : Nat) : (b : Nat) ->
        Path Nat (add (succ a) b) (succ (add a b)) = split
  zero -> <_> succ a
  succ b -> <i> succ (addSucc a b @ i)

addComm (a : Nat) : (b : Nat) -> Path Nat (add a b) (add b a) = split
  zero -> <i> addZero a @ -i
  succ b -> <i> comp (refl U Nat) (succ (addComm a b @ i))
                     [ (i = 0) -> refl Nat (succ (add a b)),
                       (i = 1) -> <j> addSucc b a @ -j ]

zeroIdentityNat : hasIdentity Nat add zero =
  \(x : Nat) -> pair (addZero x) (refl Nat x)

addA (a b : Nat) : (c : Nat) -> Path Nat (add a (add b c)) (add (add a b) c) = split
  zero -> <_> add a b
  succ c -> <i> succ (addA a b c @ i)

multRightZero : (a : Nat) -> Path Nat zero (mult a zero) = split
  zero -> refl Nat zero
  succ a -> <i> comp (refl U Nat) ((addZero (mult a zero)) @ -i)
                     [ (i = 0) -> <j> (multRightZero a) @ -j,
		       (i = 1) -> refl Nat (add zero (mult a zero)) ]

moveSuccInAdd (a : Nat) : (b : Nat) ->
  Path Nat (add (succ a) b) (succ (add a b)) = split
  zero -> refl Nat (succ a)
  succ b -> <i> succ (moveSuccInAdd a b @ i)

multAOnSb : (a : Nat) -> (b : Nat) ->
  Path Nat (mult a (succ b)) (add (mult a b) a) = split
  zero -> \(b : Nat) -> refl Nat zero
  succ a -> \(b : Nat) ->
    <i> comp (refl U Nat) (moveSuccInAdd b (add (mult a b) a) @ i)
             [ (i = 0) -> <j> add (succ b) (multAOnSb a b @ -j),
               (i = 1) -> <j> succ (addA b (mult a b) a @ j) ]

multDistribRightSwapped (b c : Nat) : (a : Nat) ->
  Path Nat (mult (add a b) c) (add (mult a c) (mult b c)) = split
  zero -> <i> comp (refl U Nat) (mult (addZero b @ i) c)
                   [ (i = 0) -> refl Nat (mult (add zero b) c),
                     (i = 1) -> <j> addZero (mult b c) @ -j ]
  succ a ->
    <i> comp (refl U Nat) (add c (multDistribRightSwapped b c a @ i))
        [ (i = 0) -> expandSuccInMult,
	  (i = 1) -> addA c (mult a c) (mult b c) ]
    where
      hole0 :
        Path Nat (add c (mult (add a b) c)) (mult (succ (add a b)) c) =
        refl Nat (add c (mult (add a b) c))

      expandSuccInMult :
        Path Nat (add c (mult (add a b) c)) (mult (add (succ a) b) c) =
        <i> comp (refl U Nat) (hole0 @ i)
                 [ (i = 0) -> refl Nat (add c (mult (add a b) c)),
                   (i = 1) -> <j> mult (moveSuccInAdd a b @ -j) c ]

multDistribRight (a b c : Nat) :
  Path Nat (mult (add a b) c) (add (mult a c) (mult b c)) =
  multDistribRightSwapped b c a

multComm (a : Nat) : (b : Nat) -> Path Nat (mult a b) (mult b a) = split
  zero -> <i> multRightZero a @ -i
  succ b -> <i> comp (refl U Nat) (multAOnSb a b @ i)
                [ (i = 0) -> refl Nat (mult a (succ b)),
                  (i = 1) -> hole0 ]
    where
      hole0 : Path Nat (add (mult a b) a) (add a (mult b a)) =
        <i> comp (refl U Nat) (addComm (mult b a) a @ i)
                 [ (i = 0) -> <j> add (multComm b a @ j) a,
                   (i = 1) -> refl Nat (add a (mult b a))]

multDistribLeft (a b c : Nat) :
  Path Nat (mult a (add b c)) (add (mult a b) (mult a c)) =
  <i> comp (refl U Nat) (multDistribRight b c a @ i)
      [ (i = 0) -> multComm (add b c) a,
        (i = 1) -> <j> add (multComm b a @ j) (multComm c a @ j) ]

multIdentityRight (a : Nat) : Path Nat (mult a (succ zero)) a =
  multComm a (succ zero)

multAssoc (a b : Nat) : (c : Nat) -> Path Nat (mult a (mult b c)) (mult (mult a b) c) = split
  zero -> <i> comp (refl U Nat) (multRightZero a @ -i)
              [ (i = 0) -> <j> mult a (multRightZero b @ j),
                (i = 1) -> multRightZero (mult a b) ]
  succ c ->
    <i> comp (refl U Nat) (add (multAssoc a b c @ i) (mult a b))
             [ (i = 0) -> left,
               (i = 1) -> right ]
    where
      right : Path Nat (add (mult (mult a b) c) (mult a b))
                       (mult (mult a b) (succ c)) =
        <i> comp (refl U Nat)
                 (multDistribLeft (mult a b) c (succ zero) @ -i)
            [ (i = 0) -> <j> add (mult (mult a b) c)
                                 (multIdentityRight (mult a b) @ j),
              (i = 1) -> refl Nat (mult (mult a b)
                                  (add c (succ zero)))]
      hole1 : Path Nat (mult a (add (mult b c) (mult b (succ zero))))
                       (add (mult a (mult b c)) (mult a b)) =
        <i> comp (refl U Nat) (multDistribLeft a (mult b c) b @ i)
            [ (i = 0) ->
                <j> mult a (add (mult b c) (multIdentityRight b @ -j)),
              (i = 1) -> refl Nat (add (mult a (mult b c)) (mult a b)) ]
      left : Path Nat (add (mult a (mult b c)) (mult a b))
                      (mult a (mult b (succ c))) =
        <i> comp (refl U Nat)
                 (mult a (multDistribLeft b c (succ zero) @ -i))
            [ (i = 0) -> hole1,
              (i = 1) -> refl Nat (mult a (mult b (succ c)))]

commutativeMonoidOverNatAdd : isCommutativeMonoid Nat =
  ((add, zero, addA, zeroIdentityNat), addComm)

semigroupOverNatMul : isSemigroup Nat =
  (mult, multAssoc)

semiringOverNat : isSemiring Nat =
  (commutativeMonoidOverNatAdd,
   semigroupOverNatMul,
   multDistribLeft,
   multDistribRight,
   \(x : Nat) -> refl Nat zero,
   \(x : Nat) -> multComm x zero)

natSemiring : Semiring = (Nat, semiringOverNat)

-- exercise 1.9

Fin : Nat -> U = undefined
-- wtf?

-- exercise 1.11

tripleNegation (A : U) (h : not (not (not A))) : not A =
  \(x : A) -> h (\(g : A -> Empty) -> g x)

-- exercise 1.12

theorem1 (A B : U) : A -> B -> A =
  \(a : A) (b : B) -> a

theorem2 (A : U) : A -> not (not A) =
  \(a : A) (g : A -> Empty) -> g a

theorem3 (A B : U) : Coproduct (not A) (not B) -> not (Tuple A B) = split
  inl a -> \(p : Tuple A B) -> a (pr1Tuple A B p)
  inr b -> \(p : Tuple A B) -> b (pr2Tuple A B p)

-- exercise 1.13

notLEM (P : U) : not (not (Coproduct P (not P))) =
  \(h : not (Coproduct P (not P))) -> h (inr (\(x : P) -> h (inl x)))
