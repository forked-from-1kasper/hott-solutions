module definitions2 where
import hott1
import contr

pathSymInd (A : U) (x y : A) (p : Path A x y) : Path A y x =
  indPath A D d x y p
  where
    D (x y : A) (p : Path A x y) : U = Path A y x
    d (x : A) : D x x (refl A x) = refl A x

-- or this
pathSym (A : U) (x y : A) (p : Path A x y) : Path A y x =
  <i> p @ -i

compPathInd (A : U) (x y z : A) (p : Path A x y) (q : Path A y z) :
  Path A x z =
  (indPath A D d x y p) z q
  where
    D (x y : A) (p : Path A x y) : U =
      (z : A) -> (q : Path A y z) -> Path A x z
    E (x z : A) (q : Path A x z) : U =
      Path A x z
    e (x : A) : E x x (refl A x) = refl A x
    d (x z : A) (q : Path A x z) : E x z q =
      indPath A E e x z q

-- this is better
compPath (A : U) (x y z : A) (p : Path A x y) (q : Path A y z) :
  Path A x z =
  <i> comp (refl U A) (p @ i)
      [ (i = 0) -> refl A x,
        (i = 1) -> q ]

reflComposition (A : U) (x : A) :
  Path (Path A x x) (compPath A x x x (refl A x) (refl A x))
       (refl A x) =
  <k j> comp (refl U A) (refl A x @ k /\ j)
          [ (j = 0) -> refl A x,
            (j = 1) -> refl A x,
            (k = 1) -> <i> refl A x @ k /\ i ]

ru (A : U) (x y : A) (p : Path A x y) :
  Path (Path A x y) p (compPath A x y y p (refl A y)) =
  indPath A D d x y p
  where
    D (x y : A) (p : Path A x y) : U =
      Path (Path A x y) p (compPath A x y y p (refl A y))
    d (x : A) : D x x (refl A x) = <i> reflComposition A x @ -i

lu (A : U) (x y : A) (p : Path A x y) :
  Path (Path A x y) p (compPath A x x y (refl A x) p) =
  indPath A D d x y p
  where
    D (x y : A) (p : Path A x y) : U =
      Path (Path A x y) p (compPath A x x y (refl A x) p)
    d (x : A) : D x x (refl A x) = <i> reflComposition A x @ -i

lemma2 (A : U) (x y : A) (p : Path A x y) :
  Path (Path A y y) (compPath A y x y (pathSym A x y p) p) (refl A y) =
  indPath A D d x y p
  where
    D (x y : A) (p : Path A x y) : U =
      Path (Path A y y) (compPath A y x y (pathSym A x y p) p) (refl A y)
    d (x : A) : D x x (refl A x) = reflComposition A x

lemma3 (A : U) (x y : A) (p : Path A x y) :
  Path (Path A x y) (pathSym A y x (pathSym A x y p)) p =
  indPath A D d x y p
  where
    D (x y : A) (p : Path A x y) : U =
      Path (Path A x y) (pathSym A y x (pathSym A x y p)) p
    d (x : A) : D x x (refl A x) = refl (Path A x x) (refl A x)

lemma4Ind
    (A : U) (x y z w : A) (p : Path A x y)
    (q : Path A y z) (r : Path A z w) :
  Path (Path A x w) (compPath A x y w p (compPath A y z w q r))
                    (compPath A x z w (compPath A x y z p q) r) =
  undefined

Pointed : U = (A : U) * A

loopSpace (A : Pointed) : Pointed =
  (Path A.1 A.2 A.2, refl A.1 A.2)

iterLoopSpace (A : Pointed) : Nat -> Pointed = split
  zero -> loopSpace A
  succ n -> iterLoopSpace (loopSpace A) n

rWhiskering (A : U) (a b c : A) (p q : Path A a b)
  (alpha : Path (Path A a b) p q) (r : Path A b c) :
  Path (Path A a c) (compPath A a b c p r) (compPath A a b c q r) =
  <i> compPath A a b c (alpha @ i) r

lWhiskering (A : U) (a b c : A) (r s : Path A b c) (q : Path A a b)
  (beta : Path (Path A b c) r s) :
  Path (Path A a c) (compPath A a b c q r) (compPath A a b c q s) =
  <i> compPath A a b c q (beta @ i)

horizontalComp (A : U) (a b c : A) (p q : Path A a b) (r s : Path A b c)
  (alpha : Path (Path A a b) p q) (beta : Path (Path A b c) r s) :
  Path (Path A a c) (compPath A a b c p r) (compPath A a b c q s) =
  compPath (Path A a c)
    (compPath A a b c p r)
    (compPath A a b c q r)
    (compPath A a b c q s)
    (rWhiskering A a b c p q alpha r)
    (lWhiskering A a b c r s q beta)

apIndAccuracy
  (A B : U) (f : A -> B) (x y : A)
  (p : Path A x y) : Path B (f x) (f y) =
  indPath A D d x y p
   where
     D (x y : A) (p : Path A x y) : U = Path B (f x) (f y)
     d (x : A) : D x x (refl A x) = refl B (f x)

apInd (A B : U) (f : A -> B) (x y : A)
      (p : Path A x y) : Path B (f x) (f y) =
   indPath A (\(x y : A) (_ : Path A x y) -> Path B (f x) (f y))
             (\(x : A) -> refl B (f x)) x y p

-- DOUBLE FFFFUUUU
ap (A B : U) (f : A -> B) (x y : A)
   (p : Path A x y) : Path B (f x) (f y) =
   <i> f (p @ i)

trans (A : U) (P : A -> U) (x y : A) (p : Path A x y) : P x -> P y =
  indPath A D d x y p
  where
    D (x y : A) (p : Path A x y) : U = P x -> P y
    d (x : A) : D x x (refl A x) = idfun (P x)

homotopy (A : U) (P : A -> U) (f g : (x : A) -> P x) : U =
  (x : A) -> Path (P x) (f x) (g x)

homotopyIdentity (A : U) (P : A -> U) (f : (x : A) -> P x) : homotopy A P f f =
  \(x : A) -> refl (P x) (f x)

homotopyInverse (A : U) (P : A -> U) (f g : (x : A) -> P x) (h : homotopy A P f g) :
  homotopy A P g f =
  \(x : A) -> <i> (h x) @ -i

homotopyTrans (A : U) (P : A -> U) (f g h : (x : A) -> P x)
  (h1 : homotopy A P f g) (h2 : homotopy A P g h) : homotopy A P f h =
  \(x : A) -> <i> comp (refl U (P x)) (g x)
    [ (i = 0) -> <j> (h1 x) @ -j,
      (i = 1) -> h2 x ]

qinv (A B : U) (f : A -> B) : U =
  (g : B -> A) *
  (alpha : homotopy B (\(_ : B) -> B) (compose B A B f g) (idfun B)) *
  (homotopy A (\(_ : A) -> A) (compose A B A g f) (idfun A))

isEquiv (A B : U) (f : A -> B) : U =
  Tuple ((g : B -> A) * (homotopy B (\(_ : B) -> B) (compose B A B f g) (idfun B)))
        ((h : B -> A) * (homotopy A (\(_ : A) -> A) (compose A B A h f) (idfun A)))

Equiv1 (A B : U) : U = (f : A -> B) * (isEquiv A B f)

-- 4.2.4
fiber (A B : U) (f : A -> B) (y : B) : U =
  (x : A) * Path B (f x) y

-- 4.4.1
isContrFiber (A B : U) (f : A -> B) : U =
  (y : B) -> isContr (fiber A B f y)

-- this is also equiv
Equiv (A B : U) : U = (f : A -> B) * (isContrFiber A B f)

tupleMap (A B : U) (x y : Tuple A B) (p : Path (Tuple A B) x y) :
  Tuple (Path A (pr1Tuple A B x) (pr1Tuple A B y))
        (Path B (pr2Tuple A B x) (pr2Tuple A B y)) =
  pair (<i> pr1Tuple A B (p @ i)) (<i> pr2Tuple A B (p @ i))

tupleMapIsEquiv (A B : U) (x y : Tuple A B) :
  isEquiv (Path (Tuple A B) x y)
          (Tuple (Path A (pr1Tuple A B x) (pr1Tuple A B y))
                 (Path B (pr2Tuple A B x) (pr2Tuple A B y)))
          (tupleMap A B x y) = undefined

unitEquiv (x y : Unit) : Equiv (Path Unit x y) Unit =
  (\(p : Path Unit x y) -> tt,
   \(z : Unit) -> ((unitIsContr x y, <i> (uniqUnit z) @ -i),
                   ?))
  where
    unitIsContr (x : Unit) : (y : Unit) -> Path Unit x y = split
      tt -> uniqUnit x

happly (A : U) (B : A -> U) (f g : (x : A) -> B x) :
  (Path ((x : A) -> B x) f g) ->
  (x : A) -> (Path (B x) (f x) (g x)) =
  \(p : Path ((x : A) -> B x) f g) (x : A) ->
    <i> (p @ i) x

funextAxiom (A : U) (B : A -> U) (f g : (x : A) -> B x) :
  isEquiv (Path ((x : A) -> B x) f g)
          ((x : A) -> (Path (B x) (f x) (g x)))
          (happly A B f g) =
  undefined

funext (A : U) (B : A -> U) (f g : (x : A) -> B x)
  (h : (x : A) -> Path (B x) (f x) (g x)) :
  (Path ((x : A) -> B x) f g) =
  <i> \(x : A) -> (h x) @ i

idtoeqv (A B : U) (p : Path U A B) : Equiv A B = ?

ua (A B : U) : isContrFiber (Path U A B) (Equiv A B) (idtoeqv A B) = undefined