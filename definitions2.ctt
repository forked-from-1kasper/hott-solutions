module definitions2 where
import hott1
import contr

pathSymInd (A : U) (x y : A) (p : Path A x y) : Path A y x =
  indPath A D d x y p
  where
    D (x y : A) (p : Path A x y) : U = Path A y x
    d (x : A) : D x x (refl A x) = refl A x

pathSym (A : U) (x y : A) (p : Path A x y) : Path A y x =
  <i> p @ -i

compPathInd (A : U) (x y z : A) (p : Path A x y) (q : Path A y z) :
  Path A x z =
  (indPath A D d x y p) z q
  where
    D (x y : A) (p : Path A x y) : U =
      (z : A) -> (q : Path A y z) -> Path A x z
    E (x z : A) (q : Path A x z) : U =
      Path A x z
    e (x : A) : E x x (refl A x) = refl A x
    d (x z : A) (q : Path A x z) : E x z q =
      indPath A E e x z q

-- this is better
compPath (A : U) (x y z : A) (p : Path A x y) (q : Path A y z) :
  Path A x z =
  <i> comp (refl U A) (p @ i)
      [ (i = 0) -> refl A x,
        (i = 1) -> q ]

reflComposition (A : U) (x : A) :
  Path (Path A x x) (compPath A x x x (refl A x) (refl A x))
       (refl A x) =
  <k j> comp (refl U A) (refl A x @ k /\ j)
          [ (j = 0) -> refl A x,
            (j = 1) -> refl A x,
            (k = 1) -> <i> refl A x @ k /\ i ]

ru (A : U) (x y : A) (p : Path A x y) :
  Path (Path A x y) p (compPath A x y y p (refl A y)) =
  indPath A D d x y p
  where
    D (x y : A) (p : Path A x y) : U =
      Path (Path A x y) p (compPath A x y y p (refl A y))
    d (x : A) : D x x (refl A x) = <i> reflComposition A x @ -i

lu (A : U) (x y : A) (p : Path A x y) :
  Path (Path A x y) p (compPath A x x y (refl A x) p) =
  indPath A D d x y p
  where
    D (x y : A) (p : Path A x y) : U =
      Path (Path A x y) p (compPath A x x y (refl A x) p)
    d (x : A) : D x x (refl A x) = <i> reflComposition A x @ -i

lemma2 (A : U) (x y : A) (p : Path A x y) :
  Path (Path A y y) (compPath A y x y (pathSym A x y p) p) (refl A y) =
  indPath A D d x y p
  where
    D (x y : A) (p : Path A x y) : U =
      Path (Path A y y) (compPath A y x y (pathSym A x y p) p) (refl A y)
    d (x : A) : D x x (refl A x) = reflComposition A x

lemma3 (A : U) (x y : A) (p : Path A x y) :
  Path (Path A x y) (pathSym A y x (pathSym A x y p)) p =
  indPath A D d x y p
  where
    D (x y : A) (p : Path A x y) : U =
      Path (Path A x y) (pathSym A y x (pathSym A x y p)) p
    d (x : A) : D x x (refl A x) = refl (Path A x x) (refl A x)

lemma4Ind
    (A : U) (x y z w : A) (p : Path A x y)
    (q : Path A y z) (r : Path A z w) :
  Path (Path A x w) (compPath A x y w p (compPath A y z w q r))
                    (compPath A x z w (compPath A x y z p q) r) =
  undefined

Pointed : U = (A : U) * A

loopSpace (A : Pointed) : Pointed =
  (Path A.1 A.2 A.2, refl A.1 A.2)

iterLoopSpace (A : Pointed) : N -> Pointed = split
  zero -> loopSpace A
  succ n -> iterLoopSpace (loopSpace A) n

rWhiskering (A : U) (a b c : A) (p q : Path A a b)
  (alpha : Path (Path A a b) p q) (r : Path A b c) :
  Path (Path A a c) (compPath A a b c p r) (compPath A a b c q r) =
  <i> compPath A a b c (alpha @ i) r

lWhiskering (A : U) (a b c : A) (r s : Path A b c) (q : Path A a b)
  (beta : Path (Path A b c) r s) :
  Path (Path A a c) (compPath A a b c q r) (compPath A a b c q s) =
  <i> compPath A a b c q (beta @ i)

horizontalComp (A : U) (a b c : A) (p q : Path A a b) (r s : Path A b c)
  (alpha : Path (Path A a b) p q) (beta : Path (Path A b c) r s) :
  Path (Path A a c) (compPath A a b c p r) (compPath A a b c q s) =
  compPath (Path A a c)
    (compPath A a b c p r)
    (compPath A a b c q r)
    (compPath A a b c q s)
    (rWhiskering A a b c p q alpha r)
    (lWhiskering A a b c r s q beta)

apIndAccuracy
  (A B : U) (f : A -> B) (x y : A)
  (p : Path A x y) : Path B (f x) (f y) =
  indPath A D d x y p
   where
     D (x y : A) (p : Path A x y) : U = Path B (f x) (f y)
     d (x : A) : D x x (refl A x) = refl B (f x)

apInd (A B : U) (f : A -> B) (x y : A)
      (p : Path A x y) : Path B (f x) (f y) =
   indPath A (\(x y : A) (_ : Path A x y) -> Path B (f x) (f y))
             (\(x : A) -> refl B (f x)) x y p

ap (A B : U) (f : A -> B) (x y : A)
   (p : Path A x y) : Path B (f x) (f y) =
   <i> f (p @ i)

transInd (A : U) (P : A -> U) (x y : A) (p : Path A x y) : P x -> P y =
  indPath A D d x y p
  where
    D (x y : A) (p : Path A x y) : U = P x -> P y
    d (x : A) : D x x (refl A x) = idfun (P x)

trans (A : U) (P : A -> U) (x y : A) (p : Path A x y) (a : P x) : P y =
  transport (<i> P (p @ i)) a

homotopy (A : U) (P : A -> U) (f g : (x : A) -> P x) : U =
  (x : A) -> Path (P x) (f x) (g x)

homotopyIdentity (A : U) (P : A -> U) (f : (x : A) -> P x) : homotopy A P f f =
  \(x : A) -> refl (P x) (f x)

homotopyInverse (A : U) (P : A -> U)
  (f g : (x : A) -> P x) (h : homotopy A P f g) :
  homotopy A P g f =
  \(x : A) -> <i> (h x) @ -i

homotopyTrans (A : U) (P : A -> U) (f g h : (x : A) -> P x)
  (h1 : homotopy A P f g) (h2 : homotopy A P g h) : homotopy A P f h =
  \(x : A) -> <i> comp (refl U (P x)) (g x)
    [ (i = 0) -> <j> (h1 x) @ -j,
      (i = 1) -> h2 x ]

qinv (A B : U) (f : A -> B) : U =
  (g : B -> A) *
  (alpha : homotopy B (\(_ : B) -> B) (compose B A B f g) (idfun B)) *
  (homotopy A (\(_ : A) -> A) (compose A B A g f) (idfun A))

isEquiv (A B : U) (f : A -> B) : U =
  Tuple
    ((g : B -> A) * (homotopy B (\(_ : B) -> B) (compose B A B f g) (idfun B)))
    ((h : B -> A) * (homotopy A (\(_ : A) -> A) (compose A B A h f) (idfun A)))

EquivTrivial (A B : U) : U = (f : A -> B) * (isEquiv A B f)

uaEquivTrivial (A B : U) : EquivTrivial A B -> Path U A B = undefined

-- 4.2.4, with reversed path
fiber (A B : U) (f : A -> B) (y : B) : U =
  (x : A) * Path B y (f x)

-- 4.4.1
isContrFiber (A B : U) (f : A -> B) : U =
  (y : B) -> isContr (fiber A B f y)

-- this is also equiv
Equiv (A B : U) : U = (f : A -> B) * (isContrFiber A B f)

invPath (A : U) (x y : A) (p : Path A x y) : Path A y x =
  <i> p @ -i

equivTrivialId (A : U) : EquivTrivial A A =
  (idfun A,
   pair (idfun A, refl A) (idfun A, refl A))

equivId (A : U) : Equiv A A =
  (idfun A, \(a : A) ->
    ((a, refl A a), hole a))
  where
    hole (a : A) (p : (x : A) * Path A a x) :
      Path ((x : A) * Path A a x) (a, <i> a) p =
      <i> (p.2 @ i, <j> p.2 @ i /\ j)

tuplePairEquiv (A B : U) (a c : A) (b d : B) :
  EquivTrivial (Path (Tuple A B) (pair a b) (pair c d))
               (Tuple (Path A a c) (Path B b d)) =
  (lem1, pair (lem2, lem3) (lem2, lem4))
  where
    lem1 (p : Path (Tuple A B) (pair a b) (pair c d)) :
      Tuple (Path A a c) (Path B b d) =
      pair (<i> pr1Tuple A B (p @ i)) (<i> pr2Tuple A B (p @ i))
    lem2 : Tuple (Path A a c) (Path B b d) ->
           Path (Tuple A B) (pair a b) (pair c d) = split
      pair p q -> <i> pair (p @ i) (q @ i)
    lem3 : (x : Tuple (Path A a c) (Path B b d)) ->
           Path (Tuple (Path A a c) (Path B b d))
                (pair (<i> pr1Tuple A B (lem2 x @ i))
                      (<i> pr2Tuple A B (lem2 x @ i))) x = split
      pair p q -> refl (Tuple (Path A a c) (Path B b d)) (pair p q)
    lem4 (x : Path (Tuple A B) (pair a b) (pair c d)) :
         Path (Path (Tuple A B) (pair a b) (pair c d))
              (<i> pair (pr1Tuple A B (x @ i))
                        (pr2Tuple A B (x @ i))) x = undefined

tupleMap (A B : U) (x y : Tuple A B) (p : Path (Tuple A B) x y) :
  Tuple (Path A (pr1Tuple A B x) (pr1Tuple A B y))
        (Path B (pr2Tuple A B x) (pr2Tuple A B y)) =
  pair (<i> pr1Tuple A B (p @ i)) (<i> pr2Tuple A B (p @ i))

tupleMapIsEquiv (A B : U) (x y : Tuple A B) :
  isEquiv (Path (Tuple A B) x y)
          (Tuple (Path A (pr1Tuple A B x) (pr1Tuple A B y))
                 (Path B (pr2Tuple A B x) (pr2Tuple A B y)))
          (tupleMap A B x y) = undefined

unitIsContr (x : Unit) : (y : Unit) -> Path Unit x y = split
  tt -> uniqUnit x

unitEquivTrivial (x y : Unit) : EquivTrivial (Path Unit x y) Unit =
  (\(p : Path Unit x y) -> tt,
   pair (backFunc x y, unitIsContr tt)
        (backFunc x y, hole))
  where
    backFunc : (x y : Unit) -> Unit -> Path Unit x y = split
      tt -> split@((y : Unit) -> Unit -> Path Unit tt y) with
        tt -> \(z : Unit) -> refl Unit tt
    hole (p : Path Unit x y) : Path (Path Unit x y) (backFunc x y tt) p =
      indPath Unit (\(x y : Unit) (p : Path Unit x y) ->
                     Path (Path Unit x y) (backFunc x y tt) p)
        (\(z : Unit) -> indUnit (\(z : Unit) ->
          Path (Path Unit z z) (backFunc z z tt) (refl Unit z))
          (refl (Path Unit tt tt) (refl Unit tt)) z) x y p

unitPathUnitPath (x y : Unit) : Path U (Path Unit x y) Unit =
  uaEquivTrivial (Path Unit x y) Unit (unitEquivTrivial x y)

onlyReflInPathUnit (x : Unit) (p : Path Unit x x) :
  Path (Path Unit x x) (refl Unit x) p = undefined

unitPathUniq (x y : Unit) (p q : Path Unit x y) : Path (Path Unit x y) p q =
  indPath Unit (\(x y : Unit) (p : Path Unit x y) ->
    (q : Path Unit x y) -> Path (Path Unit x y) p q)
    onlyReflInPathUnit x y p q

unitEquiv (x y : Unit) : Equiv (Path Unit x y) Unit =
  (\(p : Path Unit x y) -> tt,
   \(z : Unit) ->
     ((unitIsContr x y, unitIsContr z tt),
      \(h : Sigma (Path Unit x y) (Path Unit z tt)) ->
        <i> (unitPathUniq x y (unitIsContr x y) h.1 @ i,
             unitPathUniq z tt (unitIsContr z tt) h.2 @ i)))

happly (A : U) (B : A -> U) (f g : (x : A) -> B x) :
  (Path ((x : A) -> B x) f g) ->
  (x : A) -> (Path (B x) (f x) (g x)) =
  \(p : Path ((x : A) -> B x) f g) (x : A) ->
    <i> (p @ i) x

funextTheorem (A : U) (B : A -> U) (f g : (x : A) -> B x) :
  EquivTrivial (Path ((x : A) -> B x) f g)
               ((x : A) -> Path (B x) (f x) (g x)) =
  (lem1, pair (lem2, lem3) (lem2, lem4))
  where
    lem1 (p : Path ((x : A) -> B x) f g) :
         ((x : A) -> Path (B x) (f x) (g x)) =
      \(x : A) -> <i> (p @ i) x
    lem2 (p : (x : A) -> Path (B x) (f x) (g x)) :
         Path ((x : A) -> B x) f g =
      <i> \(x : A) -> (p x) @ i
    lem3 (p : (x : A) -> Path (B x) (f x) (g x)) :
         Path ((x : A) -> Path (B x) (f x) (g x))
              (\(x : A) -> <i> p x @ i) p =
      <i> \(x : A) -> p x
    lem4 (p : Path ((x : A) -> B x) f g) :
         Path (Path ((x : A) -> B x) f g)
              (<i> \(x : A) -> (p @ i) x) p =
      refl (Path ((x : A) -> B x) f g) p

funextAxiom (A : U) (B : A -> U) (f g : (x : A) -> B x) :
  isEquiv (Path ((x : A) -> B x) f g)
          ((x : A) -> (Path (B x) (f x) (g x)))
          (happly A B f g) =
  (funextTheorem A B f g).2

funext (A : U) (B : A -> U) (f g : (x : A) -> B x)
  (h : (x : A) -> Path (B x) (f x) (g x)) :
  (Path ((x : A) -> B x) f g) =
  <i> \(x : A) -> (h x) @ i

idtoeqv (A B : U) (p : Path U A B) : Equiv A B =
  transport (<i> Equiv A (p @ i)) (equivId A)

ua (A B : U) : isContrFiber (Path U A B) (Equiv A B) (idtoeqv A B) = undefined

funEq (A B : U) (f : A -> B) : Path (A -> B) (\(x : A) -> f x) f =
  <i> \(x : A) -> f x

tupleUnivProperty (A B X : U) :
  EquivTrivial (X -> Tuple A B) (Tuple (X -> A) (X -> B)) =
  (func,
   pair (backFunc, lem1)
        (backFunc, lem2))
  where
    func (f : X -> Tuple A B) : Tuple (X -> A) (X -> B) =
      pair (\(x : X) -> pr1Tuple A B (f x))
           (\(x : X) -> pr2Tuple A B (f x))
    backFunc : Tuple (X -> A) (X -> B) -> (X -> Tuple A B) = split
      pair f g -> \(x : X) -> pair (f x) (g x)
    lem1 : (x : Tuple (X -> A) (X -> B)) -> Path (Tuple (X -> A) (X -> B))
      (pair (\(y : X) -> pr1Tuple A B (backFunc x y))
            (\(y : X) -> pr2Tuple A B (backFunc x y))) x = split
      pair f g -> <i> pair (funEq X A f @ i) (funEq X B g @ i)
    lem2 (f : X -> (Tuple A B)) : Path (X -> Tuple A B)
      (\(x : X) -> pair (pr1Tuple A B (f x))
                        (pr2Tuple A B (f x))) f =
      <i> \(x : X) -> uniqTuple A B (f x) @ i

codeNat : N -> N -> U = split
  zero -> split@(N -> U) with
    zero -> Unit
    succ n -> Empty
  succ m -> split@(N -> U) with
    zero -> Empty
    succ n -> codeNat m n

r : (n : N) -> codeNat n n = split
  zero -> tt
  succ n -> r n

encode (m n : N) (p : Path N m n) : codeNat m n =
  trans N (codeNat m) m n p (r m)

decode : (m n : N) -> (p : codeNat m n) -> Path N m n = split
  zero -> split@((n : N) -> codeNat zero n -> Path N zero n) with
    zero -> \(p : Unit) -> refl N zero
    succ n -> recEmpty (Path N zero (succ n))
  succ m -> split@((n : N) -> codeNat (succ m) n -> Path N (succ m) n) with
    zero -> recEmpty (Path N (succ m) zero)
    -- this is win
    succ n -> \(p : codeNat m n) -> <i> succ (decode m n p @ i)

zeroIsNotSuccessor (m : N) : Path N (succ m) zero -> Empty =
  encode (succ m) zero

succIsInj (m n : N) (p : Path N (succ m) (succ n)) : Path N m n =
  decode m n (encode (succ m) (succ n) p)

natPathEquiv (m n : N) : EquivTrivial (Path N m n) (codeNat m n) =
  (encode m n,
   pair (decode m n, lem1) (decode m n, lem2))
  where
    lem1 (p : codeNat m n) :
      Path (codeNat m n)
           (transport (<i> codeNat m (decode m n p @ i)) (r m)) p = ?
    lem2 (p : Path N m n) :
      Path (Path N m n)
           (decode m n (transport (<i> codeNat m (p @ i)) (r m))) p = ?