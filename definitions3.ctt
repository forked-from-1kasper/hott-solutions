module definitions3 where
import hott2
import contr

isSet (A : U) : U = (x y : A) ->
  (p q : Path A x y) -> Path (Path A x y) p q
Set : U = (A : U) * (isSet A)

unitTypeIsSet : isSet Unit =
  \(x y : Unit) (p q : Path Unit x y) ->
    unitPathUniq x y p q

emptyTypeIsSet : isSet Empty =
  \(x y : Empty) (p q : Path Empty x y) ->
    recEmpty (Path (Path Empty x y) p q) x

Type1 (A : U) : U =
  (x y : A) -> (p q : Path A x y) ->
  (r s : Path (Path A x y) p q) ->
    Path (Path (Path A x y) p q) r s

setIsType1 (A : U) (set : isSet A) : Type1 A = undefined

negationOfDoubleNegation (A : U) : not (not (not A) -> A) =
  undefined

negationOfLawOfExcludedMiddle (A : U) : not (Coproduct A (not A)) = split
  inl a -> negationOfDoubleNegation A (\(h : (A -> Empty) -> Empty) -> a)
  inr a -> negationOfDoubleNegation A (\(h : (A -> Empty) -> Empty) ->
    recEmpty A (h a))

isProp (P : U) : U = (x y : P) -> (Path P x y)
Prop : U = (P : U) * (isProp P)

propEquivUnit (P : U) (prop : isProp P) (x : P) : EquivTrivial P Unit =
  (\(x : P) -> tt,
   pair (\(y : Unit) -> x, unitIsContr tt)
        (\(y : Unit) -> x, prop x))

propEquivTrivial (P Q : U) (p : isProp P) (q : isProp Q)
  (f : P -> Q) (g : Q -> P) : EquivTrivial P Q =
  (f, pair (g, \(x : Q) -> q (f (g x)) x)
           (g, \(y : P) -> p (g (f y)) y))

-- from lectures from cubicaltt repository
propIsSet (P : U) (prop : isProp P) : isSet P =
  \(x y : P) (p q : Path P x y) ->
    <j i> comp (refl U P) x
      [ (i = 0) -> prop x x,
        (i = 1) -> prop x y,
        (j = 0) -> prop x (p @ i),
        (j = 1) -> prop x (q @ i) ]

isPropIsProp (P : U) : isProp (isProp P) =
  \(f g : isProp P) ->
    <i> \(x y : P) -> propIsSet P f x y (f x y) (g x y) @ i

isSetIsProp (P : U) : isProp (isSet P) =
  \(f g : isSet P) ->
    <i> \(x y : P) (p q : Path P x y) ->
      setIsType1 P f x y p q (f x y p q) (g x y p q) @ i

LEM : U = (A : U) -> isProp A -> Sigma A (not A)
lawOfDoubleNegation : U = (A : U) -> isProp A -> (not (not A) -> A)
higherLEM : U = (A : U) -> Sigma A (not A)

isDecidable (A : U) : U = Sigma A (not A)
isDecidableFamily (A : U) (B : A -> U) : U = (a : A) -> Sigma (B a) (not (B a))

SetUniverse : U = (A : U) * (isSet A)
PropUniverse : U = (A : U) * (isProp A)

data trunc (A : U) =
    elem (a : A)
  | uniq (x y : trunc A) <i>
    [ (i = 0) -> x, (i = 1) -> y ]

recTrunc (A B : U) (prop : isProp B) (f : A -> B) (g : trunc A -> B) :
  (a : A) -> Path B (g (elem a)) (f a) =
  \(a : A) -> prop (g (elem a)) (f a)

True : U = Unit
False : U = Empty
And (P Q : U) : U = Tuple P Q
Implies (P Q : U) : U = P -> Q
Iff (P Q : U) : U = Path U P Q
-- Not is already defined
Or (P Q : U) : U = trunc (Sigma P Q)
Forall (A : U) (P : A -> U) : U = (x : A) -> P x
Exists (A : U) (P : A -> U) : U = trunc ((x : A) * (P x))

Intersection (A : U) (P Q : A -> U)
  (p : (x : A) * P x) (q : (x : A) * P x) : U =
  (x : A) * And (P x) (Q x)

Union (A : U) (P Q : A -> U)
  (p : (x : A) * P x) (q : (x : A) * P x) : U =
  (x : A) * Or (P x) (Q x)

AC (X : U) (setX : isSet X)
  (A : X -> U) (setA : (x : X) -> A x)
  (P : (x : X) -> A x -> U)
  (propP : (x : X) -> (a : A x) -> isProp (P x a)) :
  ((x : X) -> trunc ((a : A x) * (P x a))) ->
  trunc ((g : (x : X) -> A x) * ((x : X) -> P x (g x))) = undefined

univTruncProp (A B : U) (prop : isProp B) (f : A -> B) : trunc A -> B = split
  elem a -> f a
  uniq x y @ i ->
    prop (univTruncProp A B prop f x) (univTruncProp A B prop f y) @ i

fromTrunc (P : U) (prop : isProp P) : trunc P -> P =
  univTruncProp P P prop (idfun P)

truncIsProp (P : U) : isProp (trunc P) =
  \(x y : trunc P) -> <i> uniq{trunc P} x y @ i

truncIsSet (P : U) : isSet (trunc P) =
  propIsSet (trunc P) (truncIsProp P)

truncInv (P : U) (prop : isProp P) : (p : trunc P) ->
  Path (trunc P) p (elem (fromTrunc P prop p)) = undefined

propEquivTrivialTruncProp (P : U) (prop : isProp P) : EquivTrivial P (trunc P) =
  (\(p : P) -> elem p,
   pair (fromTrunc P prop,
          \(p : trunc P) -> <i> truncInv P prop p @ -i)
        (fromTrunc P prop, refl P))

propEquivTruncatedProp (P : U) (prop : isProp P) : Equiv P (trunc P) =
  (\(p : P) -> elem p,
   \(p : trunc P) ->
     ((fromTrunc P prop p, truncInv P prop p), ?))