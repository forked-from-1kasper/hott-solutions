module hott2 where
import definitions2

-- exercise 2.6
equivFunc (A : U) (x y z : A) (p : Path A x y) :
  biinv (Path A y z) (Path A x z) (compPath A x y z p) =
  pair
    (pAndResultToQ, \(q : Path A x z) -> ?)
    (pAndResultToQ, \(q : Path A y z) -> ?)
  where
    pAndResultToQ (q : Path A x z) : Path A y z =
      <i> comp (refl U A) x [ (i = 0) -> p, (i = 1) -> q ]

-- exercise 2.9
coproductUnivProp (A B X : U) :
  BiinvEquiv (Coproduct A B -> X) (Tuple (A -> X) (B -> X)) =
  (func,
   pair (revFunc, lem1)
        (revFunc, lem3))
  where
    mirror (f : A -> X) (g : B -> X) : (Coproduct A B -> X) = split
       inl a -> f a
       inr b -> g b
    func (f : Coproduct A B -> X) : Tuple (A -> X) (B -> X) =
      pair (\(a : A) -> f (inl a)) (\(b : B) -> f (inr b))
    revFunc : (Tuple (A -> X) (B -> X)) -> ((Coproduct A B) -> X) = split
      pair f g -> mirror f g
    lem1 : (x : Tuple (A -> X) (B -> X)) ->
      Path (Tuple (A -> X) (B -> X))
           (pair (\(a : A) -> revFunc x (inl a))
                 (\(b : B) -> revFunc x (inr b))) x = split
      pair f g -> <i> pair (funEq A X f @ i) (funEq B X g @ i)
    lem2 (f : Coproduct A B -> X) : (x : Coproduct A B) ->
      Path X (mirror (\(a : A) -> f (inl a))
                     (\(b : B) -> f (inr b)) x) (f x) = split
        inl a -> refl X (f (inl a))
        inr b -> refl X (f (inr b))
    lem3 (f : Coproduct A B -> X) :
      Path (Coproduct A B -> X)
           (mirror (\(a : A) -> f (inl a))
                   (\(b : B) -> f (inr b))) f =
      <i> \(x : Coproduct A B) -> lem2 f x @ i

-- exercise 2.16
funextFromHomotopy (A : U) (B : A -> U) (f g : (x : A) -> B x)
  (funext : homotopy A B f g -> Path ((x : A) -> B x) f g) :
  BiinvEquiv (Path ((x : A) -> B x) f g)
             ((x : A) -> Path (B x) (f x) (g x)) =
  (lem1, pair (funext, lem2) (funext, ?))
  where
    lem1 (p : Path ((x : A) -> B x) f g) (x : A) : Path (B x) (f x) (g x) =
      <i> (p @ i) x
    lem2 (p : (x : A) -> Path (B x) (f x) (g x)) :
      Path ((x : A) -> Path (B x) (f x) (g x)) (lem1 (funext p)) p = ?

-- exercise 2.17
equivTuple (A A' B B' : U)
  (equivA : BiinvEquiv A A')
  (equivB : BiinvEquiv B B') :
  BiinvEquiv (Tuple A B) (Tuple A' B') =
  (lem1, pair (lem2, lem3) (lem2, ?))
  where
    lem1 : Tuple A B -> Tuple A' B' = split
      pair a b -> pair (equivA.1 a) (equivB.1 b)
    lem2 : Tuple A' B' -> Tuple A B = split
      pair a' b' ->
        let
          f : A' -> A =
            (pr1Tuple (linv A A' equivA.1)
                      (rinv A A' equivA.1) equivA.2).1
          g : B' -> B =
            (pr1Tuple (linv B B' equivB.1)
                      (rinv B B' equivB.1) equivB.2).1 in
        pair (f a') (g b')
    lem3 : (x : Tuple A' B') -> Path (Tuple A' B') (lem1 (lem2 x)) x = undefined
